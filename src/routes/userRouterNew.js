const { Router } = require("express");
/*While there are many types of two-way encryption, hash functions
are ONE-WAY encryption, which makes them even tougher codes to crack. */
const bcrypt = require("bcrypt"); // is a hash function used to hash passwords.
// const hashedPassword = await bcrypt.hash(password, salt)
// the larger the salt, the longer it takes to hash password!
const userRouter = Router();
/*In cryptography, a salt is random data fed as an additional
input to a one-way function that hashes data, a password or passphrase.  */
const saltRounds = 10;
/*
With "salt round" they actually mean the cost factor.
The cost factor controls how much time is needed to calculate
a single BCrypt hash. The higher the cost factor, the more hashing
rounds are done. Increasing the cost factor by 1 doubles the
necessary time. The more time is necessary, the more difficult
is brute-forcing.

The salt (generated by bcrypt) is a random value,
and should differ for each calculation,
so the result should hardly ever be the same, even for equal passwords.

The salt is usually included in the resulting hash-string in readable
form. So with storing the hash-string you also store the salt.

Since encryption is two-way, the data can be decrypted so it is
readable again. Hashing, on the other hand, is one-way,
meaning the plaintext is scrambled into a unique digest,
through the use of a salt, that cannot be decrypted.
Hashes cannot be decrypted because they are not encrypted (i.e. not two way).
encryption = two-way function (encrypt-decrypt)
hash = one-way (encrypt/convert to hash and never can be decrypted).

Two same original strings when hashed produces two identical hashes.
This way we authenticate user in login by comparing the hashes
one hash comes from the password the user just inputted
another hash is the one generated when user first registered
password.

Hashing basics: Hashing is based on the idea that if two strings
are equal, they should have the same hash value. Therefore,
to compare two strings, you can actually compare their hashes,
instead of comparing each character.

Salting is the process of adding a random value, called a salt,
to the password before hashing it. Salting makes it harder for
attackers to crack passwords using pre-computed tables of hashes,
known as "rainbow tables", or guessing common passwords,
known as brute-force attacks.

A rainbow table is a password hacking tool that uses a precomputed
table of "reversed password hashes" to crack passwords in a database.
By using these rainbow tables, an attacker can reverse a
hashed password back to its plaintext form more efficiently
than by using brute-force.

Salting is the practice of adding a random or unique value to the
password before hashing it. The salt value is then stored alongside
the hashed password. This adds an extra layer of security by
ensuring that **even if two users have the same password, their
hashed values will be different due to the unique salts**.

The performance of salting depends on the length and the randomness
of the salt. The salt should be long enough to prevent collisions,
which are cases where two different passwords produce the same hash.
The salt should also be random enough to prevent predictability,
which is when attackers can guess the salt based on patterns or clues.

During registration:
const salt = await bcrypt.genSalt(10);
const hashedPassword = await bcrypt.hash(password, salt);
const userObj = { name, email, password: hashedPassword };

During login:
Compare the provided password with the stored hashed password
const isPasswordValid = await bcrypt.compare(password, storedHashedPassword);

To avoid two users same password, we "salt" our hash using salt.
i.e. add salt to create unique hash.
salt != salt rounds
Then "salt rounds" dictate HOW MANY TIMES we perform HASHING (with salt).
more rounds mean more security as we hash it further,
at the cost of more computing power.
so larger the salt rounds it will take more time to generate a single
hash since it will be the result of more hashing.

SALT ROUNDS is the number of times bcrypt performs the hash function.
The point is to make hashing as slow as acceptably possible,
so it takes an attacker a longer time to generate their own hash
to compare. The higher the number of salt rounds, the more times
the hash is performed, and the more secure your hash is.
*/
const { User } = require("../models/User");
const { upload } = require("../middleware/imageUpload");

userRouter.get("/", async function (req, res) {
  try {
    const users = await User.find();
    return res.send({ users });
  } catch (error) {
    return res.status(500).send({ error: error.message });
  }
});

userRouter.get("/:userId", async function (req, res) {
  try {
    const { userId } = req.params;
    const user = await User.findById({ _id: userId });
    return res.send({ user });
  } catch (error) {
    return res.status(500).send({ error: error.message });
  }
});
userRouter.post(
  "/register",
  upload.single("profileImage"),
  async function (req, res) {
    try {
      const salt = await bcrypt.genSalt(saltRounds);
      const { password, username, email, role } = req.body;
      // or can do const {hash} = require("bcrypt");
      // instead of const bcrypt = require("bcrypt");
      // then do await hash() instead of await bcrypt.hash()
      const hashedPassword = await bcrypt.hash(password, salt);
      const { filename, originalname } = req.file;
      const profilePic = { filename, originalFileName: originalname };
      const user = new User({
        password: hashedPassword,
        username,
        email,
        role,
        image: profilePic,
      });
      console.log("password:", password, "hashed psasword:", hashedPassword);
      await user.save();
      return res.send({ user });
    } catch (error) {
      return res.status(500).send({ error: error.message });
    }
  }
);

userRouter.delete("/:userId", async function (req, res) {
  try {
  } catch (error) {
    return res.status(500).send({ error: error.message });
  }
});

module.exports = { userRouter };
